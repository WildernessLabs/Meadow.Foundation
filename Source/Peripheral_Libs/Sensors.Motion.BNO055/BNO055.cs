using Meadow.Foundation.Helpers;
using Meadow.Foundation.Spatial;
using Meadow.Hardware;
using System;
using System.Threading;

namespace Meadow.Foundation.Sensors.Motion
{
    /// <summary>
    ///     Provide methods / properties to allow an application to control a BNO055 
    ///     9-axis absolute orientation sensor.
    /// </summary>
    /// <remarks>
    ///     By defult the sensor will start with the following configuration:
    /// 
    ///     Range           Range       Bandwidth
    ///     Accelerometer   4G          62.5 Hz
    ///     Magnetometer    N/A         10 Hz
    ///     Gyroscope       2000 dps    32 Hz
    /// </remarks>
	public class BNO055
	{
        #region Enums

	    /// <summary>
	    ///     Error codes that may be generated by the sensor.
	    /// </summary>
	    public enum ErrorCodes : byte
	    {
	        /// <summary>
	        ///     No error.
	        /// </summary>
	        NoError = 0x00,

	        /// <summary>
	        ///     Peripheral initialization error.
	        /// </summary>
	        PeripheralInitializationError = 0x01,

	        /// <summary>
	        ///     System initialization error.
	        /// </summary>
	        SystemInitializationError = 0x02,

	        /// <summary>
	        ///     Self test failed.
	        /// </summary>
	        SelfTestFailed = 0x04,

	        /// <summary>
	        ///     Register map value out of range.
	        /// </summary>
	        RegisterMapValueError = 0x05,

	        /// <summary>
	        ///     Register map address out of range.
	        /// </summary>
	        RegisterMapAddressError = 0x06,

	        /// <summary>
	        ///     Low power mode not available for the selected mode.
	        /// </summary>
	        LowPowerModeNotAvailable = 0x07,

	        /// <summary>
	        ///     Accelerometer power mode not available.
	        /// </summary>
	        AccelerationModeNotAvailable = 0x08,

	        /// <summary>
	        ///     Fusion algorithm configuration error.
	        /// </summary>
	        FusionConfigurationError = 0x09,

	        /// <summary>
	        ///     Sensor configuration error.
	        /// </summary>
	        SensorConfigurationError = 0x0a
	    }

	    /// <summary>
	    ///     System status codes.
	    /// </summary>
	    public enum SystemStatusCodes : byte
	    {
            /// <summary>
            ///     System is idle.
            /// </summary>
	        Idle = 0x00,

            /// <summary>
            ///     System error.
            /// </summary>
            SystemError = 0x01,

            /// <summary>
            ///     Peripheral initialization in progess.
            /// </summary>
            PeripheralInitializationInProgess = 0x02,

            /// <summary>
            ///     System is initializing.
            /// </summary>
            SystemInitializationInProgress = 0x03,

            /// <summary>
            ///     Self test is running.
            /// </summary>
            SelfTestInProgress = 0x04,

            /// <summary>
            ///     Fusion algorithm is running.
            /// </summary>
            FusionAlgorithmRunning = 0x05,

            /// <summary>
            ///     System is running without using the fusion algorithm.
            /// </summary>
            FusionAlgorithmNotUsed = 0x06
	    }

        /// <summary>
        ///     Units of measurement used by this sensor.
        /// </summary>
	    public enum Units
	    {
	        /// <summary>
	        ///     Meters per second (used for accelerometer, linear acceleration, gravity vector)
	        /// </summary>
	        MetersPerSecond = 0x01,

	        /// <summary>
	        ///     MilliG per second (used for accelerometer, linear acceleration, gravity vector)
	        /// </summary>

	        MilliG = 0xfe,

            /// <summary>
            ///     Degrees per second (angular rate) or degrees (Euler angles)
            /// </summary>
	        Degrees = 0x02,

            /// <summary>
            ///     Radians per second (angular rate) or (radians for Euler angles)
            /// </summary>
	        Radians = 0xfd,

            /// <summary>
            ///     Degrees per centigrade.
            /// </summary>
	        Centigrade = 0x20,

            /// <summary>
            ///     Degrees Fahrenheit
            /// </summary>
	        Fahrenheit = 0xef,

            /// <summary>
            ///     Readings are presented in Windows application format.
            /// </summary>
            /// <remarks>
            ///     Pich angles -180 tp +180 degrees increasing counter clockwise.
            ///     Roll angles - -90 to +90 degrees increasing with increasing inclination.
            ///     Heading / Yaw angles - 0 to 360 turning clockwise increases values
            /// </remarks>
	        Windows = 0x80,

            /// <summary>
            ///     Readings are presented in Android application format.
            /// </summary>
	        /// <remarks>
	        ///     Pich angles -180 tp +180 degrees increasing counter clockwise.
	        ///     Roll angles - -90 to +90 degrees increasing with increasing inclination.
	        ///     Heading / Yaw angles - 0 to 360 turning clockwise increases values
	        /// </remarks>
	        Android = 0x7f
	    }

        /// <summary>
        ///     Sensor type.
        /// </summary>
	    public enum Sensor
	    {
            /// <summary>
            ///     Accelerometer sensor.
            /// </summary>
	        Accelerometer = 0x00,

            /// <summary>
            ///     Gyroscope sensor.
            /// </summary>
	        Gyroscope = 0x01,

            /// <summary>
            ///     Magnetometer sensor.
            /// </summary>
	        Magnetometer = 0x02
	    };

        #endregion Enums

		#region Classes / structures

		/// <summary>
		///     Register addresses in the sensor.
		/// </summary>
        private static class Registers 
        {
            /// <summary>
            ///     Chip ID, read-only, fixed value 0xa0.
            /// </summary>
            public static readonly byte ChipID = 0x00;

            /// <summary>
            ///     Accelerometer ID, read-only, fixed to 0xfb.
            /// </summary>
            public static readonly byte AccelerometerID = 0x01;

            /// <summary>
            ///     Magnetometer ID, read-only, fixed to 0x32.
            /// </summary>
            public static readonly byte MagnetometerID = 0x02;

            /// <summary>
            ///     Gyroscope ID, read-only, fixed to 0x0f.
            /// </summary>
            public static readonly byte GyroscopeID = 0x03;

            /// <summary>
            ///     LSB of the software version number.
            /// </summary>
            public static readonly byte SoftwareRevisionIDLSB = 0x04;

            /// <summary>
            ///     MSB of the software version number.
            /// </summary>
            public static readonly byte SoftwareRevisionIDMSB = 0x05;

            /// <summary>
            ///     Bootloader version number.
            /// </summary>
            public static readonly byte BootloaderRevisionID = 0x06;

            /// <summary>
            ///     Page register.  This determines which set of registers are available, 
            ///     page 0 or page 1.
            /// 
            ///     This defaults to 0 on reset.
            /// </summary>
            public static readonly byte PageID = 0x07;

            /// <summary>
            ///     Register containing the first byte of the sensor readings.
            /// </summary>
            /// <remarks>
            ///     This is used in the calculation of the various sensor readings
            /// in the _sensorReadings member.
            /// </remarks>
            public static readonly byte StartOfSensorData = 0x08;

            /// <summary>
            ///     LSB of the X acceleration data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte AccelerometerXLSB = 0x08;

            /// <summary>
            ///     MSB of the X acceleration data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte AccelerometerXMSB = 0x09;

            /// <summary>
            ///     LSB of the Y acceleration data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte AccelerometerYLSB = 0x0a;

            /// <summary>
            ///     MSB of the Y acceleration data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte AccelerometerYMSB = 0x0b;

            /// <summary>
            ///     LSB of the Z acceleration data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte AccelerometerZLSB = 0x0c;

            /// <summary>
            ///     MSB of the Z acceleration data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte AccelerometerZMSB = 0x0d;

            /// <summary>
            ///     LSB of the X magnetometer data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte MagnetometerXLSB = 0x0e;

            /// <summary>
            ///    MSB of the X magnetometer data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte MagnetometerXMSB = 0x0f;

            /// <summary>
            ///     LSB of the Y magnetometer data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte MagnetometerYLSB = 0x10;

            /// <summary>
            ///     MSB of the Y magnetometer data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte MagnetometerYMSB = 0x11;

            /// <summary>
            ///     LSB of the Z magnetometer data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte MagnetometerZLSB = 0x12;

            /// <summary>
            ///     MSB of the Z magnetometer data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte MagnetometerZMSB = 0x13;

            /// <summary>
            ///     LSB of the X gyroscope data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte GyroscopeXLSB = 0x14;

            /// <summary>
            ///     MSB of the X gyroscope data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte GyroscopeXMSB = 0x15;

            /// <summary>
            ///     LSB of the Y gyroscope data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte GyroscopeYLSB = 0x16;

            /// <summary>
            ///     MSB of the Y gyroscope data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte GyroscopeYMSB = 0x17;

            /// <summary>
            ///     LSB of the Z gyroscope data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte GyroscopeZLSB = 0x18;

            /// <summary>
            ///     MSB of the Z gyroscope data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte GyroscopeZMSB = 0x19;

            /// <summary>
            ///     LSB of the X heading data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte EulerAngleXLSB = 0x1a;

            /// <summary>
            ///     MSB of the X heading data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte EulerAngleXMSB = 0x1b;

            /// <summary>
            ///     LSB of the Y heading data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte EulerAngleYLSB = 0x1c;

            /// <summary>
            ///     MSB of the Y heading data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte EulerAngleYMSB = 0x1d;

            /// <summary>
            ///     LSB of the Z heading data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>            public static readonly byte EulerAngleYMSB = 0x1d;
            public static readonly byte EulerAngleZLSB = 0x1e;

            /// <summary>
            ///     MSB of the Z heading data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte EulerAngleZMSB = 0x1f;

            /// <summary>
            ///     LSB of the W quaternion data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte QuaternionDataWLSB = 0x20;

            /// <summary>
            ///     MSB of the W quaternion data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte QuaternionDataWMSB = 0x21;

            /// <summary>
            ///     LSB of the X quaternion data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte QuaternionDataXLSB = 0x22;

            /// <summary>
            ///     MSB of the X quaternion data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte QuaternionDataXMSB = 0x23;

            /// <summary>
            ///     LSB of the Y quaternion data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte QuaternionDataYLSB = 0x24;

            /// <summary>
            ///     MSB of the Y quaternion data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte QuaternionDataYMSB = 0x25;

            /// <summary>
            ///     LSB of the Z quaternion data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte QuaternionDataZLSB = 0x26;

            /// <summary>
            ///     MSB of the Z quaternion data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte QuaternionDataZMSB = 0x27;

            /// <summary>
            ///     LSB of the X linear acceleration data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte LinearAccelerationXLSB = 0x28;

            /// <summary>
            ///     MSB of the X linear acceleration data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte LinearAccelerationXMSB = 0x29;

            /// <summary>
            ///     LSB of the Y linear acceleration data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte LinearAccelerationYLSB = 0x2a;

            /// <summary>
            ///     MSB of the Y linear acceleration data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte LinearAccelerationYMSB = 0x2b;

            /// <summary>
            ///     LSB of the Z linear acceleration data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte LinearAccelerationZLSB = 0x2c;

            /// <summary>
            ///     MSB of the Z linear acceleration data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte LinearAccelerationZMSB = 0x2d;

            /// <summary>
            ///     LSB of the X gravity vector data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte GravityVectorXLSB = 0x2e;


            /// <summary>
            ///     MSB of the X gravity vector data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte GravityVectorXMSB = 0x2f;

            /// <summary>
            ///     LSB of the Y gravity vector data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte GravityVectorYLSB = 0x30;

            /// <summary>
            ///     MSB of the Y gravity vector data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte GravityVectorYMSB = 0x31;

            /// <summary>
            ///     LSB of the Z gravity vector data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte GravityVectorZLSB = 0x32;

            /// <summary>
            ///     MSB of the Z gravity vector data.
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte GravityVectorZMSB = 0x33;

            /// <summary>
            ///     Temperature.
            /// 
            ///     1 LSB = 1 degree (F or C).
            /// </summary>
            /// <remarks>
            ///     The output units can be changed through the Units register and the
            ///     operation mode can be changed through the OperationMode register.
            /// </remarks>
            public static readonly byte Temperature = 0x34;

            /// <summary>
            ///     Calibration status.
            /// </summary>
            /// <remarks>
            ///     Read the calibration status for the sensor.
            ///         b0-b1: Magnetometer calibration status.
            ///         b2-b3: Accelerometer calibration status.
            ///         b4-b5: Gyroscope calibration status.
            ///         b6-b7: System calibration status.  This depends upon the 
            ///                calibration status of all of the sensors.
            /// 
            ///     3 indicates the particular sensor is fully calibrated, 0 indicates the
            ///     sensor is not calibrated.
            /// </remarks>
            public static readonly byte CalibrationStatus = 0x35;

            /// <summary>
            ///     Get the system test result.
            /// </summary>
            /// <remarks>
            ///     Allows the 
            ///         b0: Accelerometer test result.
            ///         b1: Magnetometer test result.
            ///         b2: Gyroscope test result.
            ///         b3: Microcontroller test result.
            /// 
            ///     A value of 1 indicates a pass, 0 indicates a failure.
            /// </remarks>
            public static readonly byte SelfTestResult = 0x36;

            /// <summary>
            ///     Indicate which interrupts have triggered.
            /// </summary>
            /// <remarks>
            ///     Decode the interrupt type using the following table:
            ///         b2: Gyroscope any motion
            ///         b3: Gyroscope high rate
            ///         b5: Accelerometer high rate
            ///         b6: Accelerometer any motion
            ///         b7: Accelerometer no motion or slow motion
            /// </remarks>
            public static readonly byte InterruptStatus = 0x37;

            /// <summary>
            ///     System clock statue, 0, the clock can be reconfigured.
            /// </summary>
            public static readonly byte SystemClockStatus = 0x38;

            /// <summary>
            ///     System status:
            ///         0: Idle
            ///         1: Error
            ///         2: Initializing the peripherals
            ///         3: System initialization
            ///         4: Executing self test
            ///         5: Sensor fusion algorithm is running
            ///         6: System running without the fusion algorithm
            /// </summary>
            public static readonly byte SystemStatus = 0x39;

            /// <summary>
            ///     Indicates the type of error (if any) that has occurred.
            ///         0: No error
            ///         1: Peripheral initialization error
            ///         2: System initialization error
            ///         3: Self test failed
            ///         4: Register map value out of range
            ///         5: Register map address out of range
            ///         6: Register map write error
            ///         7: Low power mode not available for selected operation mode
            ///         8: Accelerometer mor not available
            ///         9: Fusion algorithm configuration error
            ///         a: Sensor configuration error
            /// </summary>
            public static readonly byte ErrorCode = 0x3a;

            /// <summary>
            ///     Define the units for the various sensors.
            /// 
            ///         b1: Accelerometer (0 - m/s2, 1 - mg)
            ///         b2: Gyroscope (0 - degrees per seconds, 1 - radians per second)
            ///         b3: Euler units (0 - degrees, 1 - radians)
            ///         b5: Temperature (0 - Celsius, 1 - Fahrenheit)
            ///         b7: Orientation (0 - Windows, 1 - Android)
            /// </summary>
            public static readonly byte Units = 0x3b;

            /// <summary>
            ///     Operation mode.
            /// 
            ///     On power up, the sensor enters configuration mode.
            /// </summary>
            public static readonly byte OperatingMode = 0x3d;

            /// <summary>
            ///     Power mode (Normal, Low power, or Suspended).
            /// </summary>
            public static readonly byte PowerMode = 0x3e;

            /// <summary>
            ///     System trigger
            ///         b0: Trigger self test when set to 1
            ///         b5: Trigger a reset when set to 1
            ///         b6: Reset all of the interrupt status bits when set to 1
            ///         b7: 0 - use internal oscillator, 1 - use external oscillator
            /// </summary>
            public static readonly byte SystemTrigger = 0x3f;

            /// <summary>
            ///     Get / set the temperature source.
            /// 
            ///     00 - Accelerometer provides the temperature data.
            ///     01 - Gyroscope provides the temperature data.
            /// </summary>
            public static readonly byte TemperatureSource = 0x40;

            /// <summary>
            ///     Remap the axis to take into consideration the mlounting of the sensor.
            /// 
            ///     b0-b1: Remap the X axis
            ///     b2-b3: Remap the Y axis
            ///     b4-b5: Remap the Z axis
            /// 
            ///     00 - X axis
            ///     01 - Y axis
            ///     10 - Z axis
            ///     11 - Invalid.
            /// </summary>
            public static readonly byte AxisMapConfiguration = 0x41;

            /// <summary>
            ///     Sign of the axis mapping
            /// 
            ///     b0: Sign of the X axis mapping
            ///     b1: Sign of the Y axis mapping
            ///     b2: Sign of the Z axis mapping
            /// </summary>
            public static readonly byte AxisMapSign = 0x42;

            /// <summary>
            ///     Accelerometer offset X LSB
            /// </summary>
            /// <remarks>
            ///     See section 3.6.4.
            /// </remarks>
            public static readonly byte AccelerometerOffsetXLSB = 0x55;

            /// <summary>
            ///     Accelerometer offset X MSB
            /// </summary>
            /// <remarks>
            ///     See section 3.6.4.
            /// </remarks>
            public static readonly byte AccelerometerOffsetXMSB = 0x56;

            /// <summary>
            ///     Accelerometer offset Y LSB
            /// </summary>
            /// <remarks>
            ///     See section 3.6.4.
            /// </remarks>
            public static readonly byte AccelerometerOffsetYLSB = 0x57;

            /// <summary>
            ///     Accelerometer offset Y MSB
            /// </summary>
            /// <remarks>
            ///     See section 3.6.4.
            /// </remarks>
            public static readonly byte AccelerometerOffsetYMSB = 0x58;

            /// <summary>
            ///     Accelerometer offset Z LSB
            /// </summary>
            /// <remarks>
            ///     See section 3.6.4.
            /// </remarks>
            public static readonly byte AccelerometerOffsetZLSB = 0x59;

            /// <summary>
            ///     Accelerometer offset Z LSB
            /// </summary>
            /// <remarks>
            ///     See section 3.6.4.
            /// </remarks>
            public static readonly byte AccelerometerOffsetZMSB = 0x5a;

            /// <summary>
            ///     Magnetometer offset X LSB
            /// </summary>
            /// <remarks>
            ///     See section 3.6.4.
            /// </remarks>
            public static readonly byte MagnetometerOffsetXLSB = 0x5b;

            /// <summary>
            ///     Magnetometer offset X MSB
            /// </summary>
            /// <remarks>
            ///     See section 3.6.4.
            /// </remarks>
            public static readonly byte MagnetometerOffsetXMSB = 0x5c;

            /// <summary>
            ///     Magnetometer offset Y LSB
            /// </summary>
            /// <remarks>
            ///     See section 3.6.4.
            /// </remarks>
            public static readonly byte MagnetometerOffsetYLSB = 0x5d;

            /// <summary>
            ///     Magnetometer offset Y MSB
            /// </summary>
            /// <remarks>
            ///     See section 3.6.4.
            /// </remarks>
            public static readonly byte MagnetometerOffsetYMSB = 0x5e;

            /// <summary>
            ///     Magnetometer offset Z LSB
            /// </summary>
            /// <remarks>
            ///     See section 3.6.4.
            /// </remarks>
            public static readonly byte MagnetometerOffsetZLSB = 0x5f;

            /// <summary>
            ///     Magnetometer offset Z MSB
            /// </summary>
            /// <remarks>
            ///     See section 3.6.4.
            /// </remarks>
            public static readonly byte MagnetometerOffsetZMSB = 0x60;

            /// <summary>
            ///     Magnetometer offset X LSB
            /// </summary>
            /// <remarks>
            ///     See section 3.6.4.
            /// </remarks>
            public static readonly byte GyroscopeOffsetXLSB = 0x61;

            /// <summary>
            ///     Magnetometer offset X MSB
            /// </summary>
            /// <remarks>
            ///     See section 3.6.4.
            /// </remarks>
            public static readonly byte GyroscopeOffsetXMSB = 0x62;

            /// <summary>
            ///     Magnetometer offset Y LSB
            /// </summary>
            /// <remarks>
            ///     See section 3.6.4.
            /// </remarks>
            public static readonly byte GyroscopeOffsetYLSB = 0x63;

            /// <summary>
            ///     Magnetometer offset Y MSB
            /// </summary>
            /// <remarks>
            ///     See section 3.6.4.
            /// </remarks>
            public static readonly byte GyroscopeOffsetYMSB = 0x64;

            /// <summary>
            ///     Magnetometer offset Z LSB
            /// </summary>
            /// <remarks>
            ///     See section 3.6.4.
            /// </remarks>
            public static readonly byte GyroscopeOffsetZLSB = 0x65;

            /// <summary>
            ///     Magnetometer offset Z MSB
            /// </summary>
            /// <remarks>
            ///     See section 3.6.4.
            /// </remarks>
            public static readonly byte GyroscopeOffsetZMSB = 0x66;

            /// <summary>
            ///     Accelerometer radius LSB
            /// </summary>
            /// <remarks>
            ///     See section 3.6.4.
            /// </remarks>
            public static readonly byte AccelerometerRadiusLSB = 0x67;

            /// <summary>
            ///     Accelerometer radius MSB
            /// </summary>
            /// <remarks>
            ///     See section 3.6.4.
            /// </remarks>
            public static readonly byte AccelerometerRadiusMSB = 0x68;

            /// <summary>
            ///     Magnetometer radius LSB
            /// </summary>
            /// <remarks>
            ///     See section 3.6.4.
            /// </remarks>
            public static readonly byte MagnetometerRadiusLSB = 0x69;

            /// <summary>
            ///     Magnetometer radius MSB
            /// </summary>
            /// <remarks>
            ///     See section 3.6.4.
            /// </remarks>
            public static readonly byte MagnetometerRadiusMSB = 0x6a;

            /// <summary>
            ///     Configure the accelerometer
            ///         b0-b2: 
            ///         b3-b4:
            ///         b5-b7: 
            /// </summary>
            /// <remarks>
            ///     The register is in page 1.
            /// </remarks>
            public static readonly byte AccelerometerConfiguration = 0x08;

            /// <summary>
            ///     Configure the magnetometer.
            ///         b0-b2: 
            ///         b3-b4:
            ///         b5-b6: 
            /// </summary>
            /// <remarks>
            ///     The register is in page 1.
            /// </remarks>
            public static readonly byte MagnetometerConfiguration = 0x09;

            /// <summary>
            ///     Configure the gyroscope.
            ///         b0-b2: 
            ///         b3-b5:
            /// </summary>
            /// <remarks>
            ///     The register is in page 1.
            /// </remarks>
            public static readonly byte GyroscopeConfiguration0 = 0x0a;

            /// <summary>
            ///     Configure the gyroscope
            /// </summary>
            ///  <remarks>
            ///     The register is in page 1.
            ///         b0-b2: 
            /// </remarks>
            public static readonly byte GyroscopeConfiguration1 = 0x0b;

            /// <summary>
            ///     Configure the sleep options for the accelerometer.
            /// 
            ///         b0: Sleep mode,0 - use event driven time-base mode.
            ///         b1-b4: Sleep duration.
            /// 
            ///     Note that the sleep mode can only be configured then the fusion
            ///     engine is not running.
            /// </summary>
            /// <remarks>
            ///     The register is in page 1.
            /// </remarks>
            public static readonly byte AccelerometerSleepConfiguration = 0x0c;

            /// <summary>
            ///     The gyroscope can be configured to sleep in order to save power.
            /// 
            ///     b0-b2: Auto sleep duration.
            ///     b3-b5: Sleep duration.
            /// </summary>
            /// <remarks>
            ///     The register is in page 1.
            /// </remarks>
            public static readonly byte GyrosscopeSleepConfiguration = 0x0d;

            /// <summary>
            ///     Determine which interrupts are enabled / disabled.
            /// 
            ///     The InterruptStatus register will be updated for all interrupts but
            ///     the interrupt pin will only be triggered when the relevant bit in the 
            ///     InterruptMask register is set to 1.
            /// 
            ///     b2: Gyroscope interrupt when any motion is detected.
            ///     b3: Gyroscope high rate interrupt
            ///     b5: Accelerometer high rate interrupt
            ///     b6: Accelerometer, any motion interrupt
            ///     b7: Accelerometer, slow or no motion interrupt
            /// </summary>
            /// <remarks>
            ///     The register is in page 1.
            /// </remarks>
            public static readonly byte InterruptMask = 0x0f;

            /// <summary>
            ///     Enable / disable interrupts.  Setting a bit to 0 will disable interrupt
            ///     a value of 1 will enable the interrupt.
            /// 
            ///     b2: Enable / disable gyroscope interrupt
            ///     b3: Enable / disable gyroscope high rate interrupt
            ///     b5: Enable / disable accelerometer high rate interrupt
            ///     b6: Enable / disable accelerometer, any motion interrupt
            ///     b7: Enable / disable accelerometer, slow or no motion interrupt
            /// </summary>
            /// <remarks>
            ///     The register is in page 1.
            /// </remarks>
            public static readonly byte InterruptEnable = 0x10;

            /// <summary>
            ///     Accelerometer any motion threshold
            /// 
            ///     The threshold value depends upon the value in the 
            ///     AccelerometerConfiguration register.
            /// 
            ///     1 LSB = 3.91mg (2g range)
            ///     1 LSB = 7.81mg (4g range)
            ///     1 LSB = 15.63mg (8g range)
            ///     1 LSB = 31.25mg (16g range)
            /// </summary>
            /// <remarks>
            ///     The register is in page 1.
            /// </remarks>
            public static readonly byte AccelerometerMotionThreshold = 0x11;

            /// <summary>
            ///     Accelerometer interrupt settings.
            /// 
            ///     b0-b1: Any motion interrupt triggers if b1b0+1 consecutive data 
            ///            points exceed the any motion threshold.
            ///     b2: Select X axis for the any motion interrupt.
            ///     b3: Select Y axis for the any motion interrupt.
            ///     b4: Select Y axis for the any motion interrupt.
            ///     b5: Select X axis for the high rate interrupt.
            ///     b6: Select Y axis for the high rate interrupt.
            ///     b7: Select Z axis for the high rate interrupt.
            /// </summary>
            /// <remarks>
            ///     The register is in page 1.
            /// </remarks>
            public static readonly byte AccelerometerInterruptSettings = 0x12;

            /// <summary>
            ///     Accelerometer high-g interrupt duration.
            /// 
            ///     Delay before the high-g interrupt is triggered.  Delay is a
            ///     multiple of 2ms.
            /// </summary>
            /// <remarks>
            ///     The register is in page 1.
            /// </remarks>
            public static readonly byte AccelerometerHighGDuration = 0x013;

            /// <summary>
            ///     High-g threshold, this is dependent upon the setting in the range register.
            /// 
            ///     1 LSB = 7.81mg (2g range)
            ///     1 LSB = 15.63mg (4g range)
            ///     1 LSB = 31.25mg (8g range)
            ///     1 LSB = 62.5mg (16-g range)
            /// </summary>
            /// <remarks>
            ///     The register is in page 1.
            /// </remarks>
            public static readonly byte AccelerometerHighGThreshold = 0x14;

            /// <summary>
            ///     Accelerometer no motion / slow motion threshold.
            /// 
            ///     1 LSB = 3.91mg (2g range)
            ///     1 LSB = 7.81mg (4g range)
            ///     1 LSB = 15.63mg (8g range)
            ///     1 LSB = 31.25mg (16g range)
            /// </summary>
            /// <remarks>
            ///     The register is in page 1.
            /// </remarks>
            public static readonly byte AccelerometerNoMotionThreshold = 0x15;

            /// <summary>
            ///     Accelerometer slow / no motion setting.
            /// 
            ///     b0: 0 - Slow motion selected, 1 - no motion selected.
            ///     b1-b7: Slow / no motion duration
            /// </summary>
            /// <remarks>
            ///     The register is in page 1.
            /// </remarks>
            public static readonly byte AccelerometerNoMotionSetting = 0x16;

            /// <summary>
            ///     Gyroscope interrupt settings
            /// 
            ///     b0: Enable / disable the any motion interrupt on the X axis.
            ///     b1: Enable / disable the any motion interrupt on the Y axis.
            ///     b2: Enable / disable the any motion interrupt on the Z axis.
            ///     b3: Enable / disable the high rate interrupt on the X axis.
            ///     b4: Enable / disable the high rate interrupt on the Y axis.
            ///     b5: Enable / disable the high rate  interrupt on the Z axis.
            ///     b6: Select unfiltered data for the any motion interrupt.
            ///     b7: Select unfiltered data for the high rate interrupt.
            /// </summary>
            /// <remarks>
            ///     The register is in page 1.
            /// </remarks>
            public static readonly byte GyroscopeInterruptSetting = 0x17;

            /// <summary>
            ///     High rate settings for the gyroscope X axis
            /// 
            ///     b0-b4: High rate threshold for the X axis.
            ///            1 LSB - 15.625 degrees per second in 500 degrees per second range.
            ///            1 LSB - 31.25 degrees per second in 1000 degrees per second range.
            ///            1 LSB - 62.5 degrees per second in 2000 degrees per second range.
            /// 
            ///     b5-b5: High rate hysteresis for the X axis.
            ///            1 LSB - 15.625 degrees per second in 500 degrees per second range.
            ///            1 LSB - 31.25 degrees per second in 1000 degrees per second range.
            ///            1 LSB - 62.5 degrees per second in 2000 degrees per second range.
            /// </summary>
            /// <remarks>
            ///     The register is in page 1.
            /// </remarks>
            public static readonly byte GyroscopeHighRateX = 0x18;

            /// <summary>
            ///     High rate duration for the X axis.
            /// 
            ///     Actual time will be (1 + high rate duration) * 2.5 ms.
            /// </summary>
            /// <remarks>
            ///     The register is in page 1.
            /// </remarks>
            public static readonly byte GyroscopeDurationX = 0x19;

            /// <summary>
            ///     High rate settings for the gyroscope Y axis
            /// 
            ///     b0-b4: High rate threshold for the X axis.
            ///            1 LSB - 15.625 degrees per second in 500 degrees per second range.
            ///            1 LSB - 31.25 degrees per second in 1000 degrees per second range.
            ///            1 LSB - 62.5 degrees per second in 2000 degrees per second range.
            /// 
            ///     b5-b5: High rate hysteresis for the X axis.
            ///            1 LSB - 15.625 degrees per second in 500 degrees per second range.
            ///            1 LSB - 31.25 degrees per second in 1000 degrees per second range.
            ///            1 LSB - 62.5 degrees per second in 2000 degrees per second range.
            /// </summary>
            /// <remarks>
            ///     The register is in page 1.
            /// </remarks>
            public static readonly byte GyroscopeHighRateY = 0x1a;

            /// <summary>
            ///     High rate duration for the Y axis.
            /// 
            ///     Actual time will be (1 + high rate duration) * 2.5 ms.
            /// </summary>
            /// <remarks>
            ///     The register is in page 1.
            /// </remarks>
            public static readonly byte GyroscopeDurationY = 0x1b;

            /// <summary>
            ///     High rate settings for the gyroscope Z axis
            /// 
            ///     b0-b4: High rate threshold for the X axis.
            ///            1 LSB - 15.625 degrees per second in 500 degrees per second range.
            ///            1 LSB - 31.25 degrees per second in 1000 degrees per second range.
            ///            1 LSB - 62.5 degrees per second in 2000 degrees per second range.
            /// 
            ///     b5-b5: High rate hysteresis for the X axis.
            ///            1 LSB - 15.625 degrees per second in 500 degrees per second range.
            ///            1 LSB - 31.25 degrees per second in 1000 degrees per second range.
            ///            1 LSB - 62.5 degrees per second in 2000 degrees per second range.
            /// </summary>
            /// <remarks>
            ///     The register is in page 1.
            /// </remarks>
            public static readonly byte GyroscopeHighRateZ = 0x1c;

            /// <summary>
            ///     High rate duration for the Z axis.
            /// 
            ///     Actual time will be (1 + high rate duration) * 2.5 ms.
            /// </summary>
            /// <remarks>
            ///     The register is in page 1.
            /// </remarks>
            public static readonly byte GyroscopeDurationZ = 0x1d;

            /// <summary>
            ///     Gyroscope any motion threshold.
            /// 
            ///     1 LSB = 0.25 degrees per second in 500 degrees per second range.
            ///     1 LSB = 0.5 degrees per second in 1000 degrees per second range.
            ///     1 LSB = 1 degree per second in 2000 degrees per second range.
            /// </summary>
            /// <remarks>
            ///     The register is in page 1.
            /// </remarks>
            public static readonly byte GyroscopeAnyMotionThreshold = 0x1e;

            /// <summary>
            ///     Gyroscope any motion setup.
            /// 
            ///     b0-b1: Any motion trigger slope threshold.  The any motion
            ///            interrupt triggers when (1 + slope samples) * 4 data points
            ///            are above the GyroscopeAnyMotionThreshold.
            ///     b2-b3: Awake duration. 0 = 8 samples, 1 = 16 samples, 
            ///            2 = 32 samples, 3 = 64 samples.
            /// </summary>
            /// <remarks>
            ///     The register is in page 1.
            /// </remarks>
            public static readonly byte GyroscopeAnyMotionSetting = 0x1f;
        }

        /// <summary>
        ///     Self test result bit mask.
        /// </summary>
	    public static class SelfTestResultMask
        {
            /// <summary>
            ///     Accelerometer bit mask.
            /// </summary>
            public static readonly byte Accelerometer = 0x01;

            /// <summary>
            ///     Magnetometer bit mask.
            /// </summary>
            public static readonly byte Magnetometer = 0x02;

            /// <summary>
            ///     Gyroscope bit mask.
            /// </summary>
            public static readonly byte Gyroscope = 0x04;

            /// <summary>
            ///     Microcontroller bit mask.
            /// </summary>
            public static readonly byte Microcontroller = 0x08;
        }

        /// <summary>
        ///     Valis power mode.
        /// </summary>
	    public static class PowerModes
	    {
            /// <summary>
            ///     All sensors are active in normal mode.
            /// </summary>
	        public static readonly byte Normal = 0x00;

	        /// <summary>
	        ///     If no activity is detected for a configuration duration (default = 5s)
	        ///     the sensor will enter low power mode.  In this mode, only the accelerometer
	        ///     is is active and motion detected by the accelerometer then the device
	        ///     will wake.
	        /// </summary>
	        public static readonly byte LowPower = 0x00;

	        /// <summary>
	        ///     Put the sensor into Suspoend mode.  In this more no values in
	        ///     the register map will be updated.
	        /// </summary>
	        public static readonly byte Suspended = 0x00;

	    }

        /// <summary>
        ///     Possible operating modes for the sensor.
        /// </summary>
	    public static class OperatingModes
	    {
            /// <summary>
            ///     Put the sensor into configuration mode.
            /// </summary>
	        public static readonly byte ConfigurationMode = 0x00;

            /// <summary>
            ///     Turn on the accelerometer only.
            /// </summary>
	        public static readonly byte Accelerometer = 0x01;

            /// <summary>
            ///     Turn on the magnetometer only.
            /// </summary>
	        public static readonly byte Magnetometer = 0x02;

            /// <summary>
            /// Turn on the gyroscope only.
            /// </summary>
            public static readonly byte Gyroscope = 0x03;

            /// <summary>
            ///     Turn on the accelerometer and the magnetometer.
            /// </summary>
	        public static readonly byte AccelerometerMagnetometer = 0x04;

            /// <summary>
            ///     Turn on the accelerometer and the gyroscope.
            /// </summary>
	        public static readonly byte AccelerometeraGyroscope = 0x05;

            /// <summary>
            ///     Turn on the magnetometer and the gyroscope.
            /// </summary>
	        public static readonly byte MagnetometerGyroscope = 0x06;

            /// <summary>
            ///     Turn on the accelerometer, megnetometer and the gyroscope.
            /// </summary>
	        public static readonly byte AccelerometerMagnetometerGyroscope = 0x07;

            /// <summary>
            ///     Put the sensor into fusion mode intertial measurement unit mode.
            /// </summary>
	        public static readonly byte InertialMeasurementUnit = 0x08;

            /// <summary>
            ///     Operate as a compass (fusion mode).
            /// </summary>
	        public static readonly byte Compass = 0x09;

            /// <summary>
            ///     Similar to IMU mode but uses the magnetometer instead of the gyroscope (fusion mode).
            /// </summary>
	        public static readonly byte MagnetForGyroscope = 0x0a;

            /// <summary>
            ///     Same as the NineDegreesOfFreedom but with the Fast Magnetometer Calibration turned off (fusion mode).
            /// </summary>
	        public static readonly byte NineDegreesOfFreedomMagnetometerCalibrationOff = 0x0b;

            /// <summary>
            ///     Fusion of the accelerometer, gyroscope and megnetometer readings (fusion mode).
            /// </summary>
	        public static readonly byte NineDegreesOfFreedom = 0x0c;

            /// <summary>
            ///     Maximum value for the operating modes.
            /// </summary>
	        public static readonly byte MaximumValue = 0x0c;
	    }

		#endregion Classes  / structures

		#region Member variables / fields

		/// <summary>
		///     BNO055 object.
		/// </summary>
		private readonly II2cPeripheral _bno055 = null;

        /// <summary>
        ///     Sensor readings from the last time the BNO055 was polled.
        /// </summary>
        private byte[] _sensorReadings = null;

        /// <summary>
        ///     Current accelerometer units.
        /// </summary>
	    private Units _accelerometerUnits;

        /// <summary>
        ///     Units to use for the gyroscope.
        /// </summary>
	    private Units _gyroscopeUnits;

        /// <summary>
        ///     Units used for measuring angles.
        /// </summary>
	    private Units _orientationUnits;

		#endregion Member variables / fields

		#region Properties

        /// <summary>
        ///     Get the temperature from the currently selected sensor.
        /// </summary>
	    public int Temperature
	    {
	        get { return (_bno055.ReadRegister(Registers.Temperature)); }
	    }

        /// <summary>
        ///     Select the source of the Temperatute property.
        /// </summary>
	    public Sensor TemperatureSource
	    {
            get
            {
                return (Sensor) _bno055.ReadRegister(Registers.TemperatureSource);
            }
	        set
	        {
	            if ((value == Sensor.Accelerometer) || (value == Sensor.Gyroscope))
	            {
	                _bno055.WriteRegister(Registers.TemperatureSource, (byte) value);
	            }
	            else
	            {
                    throw new ArgumentException("Invlid sensor type, temperature can only be read from the Accelerometer or the Gyroscope.");
	            }
	        }
	    }

        /// <summary>
        ///     Get or set the power mode for the sensor.
        /// </summary>
	    public byte PowerMode
	    {
            get
            {
                return(_bno055.ReadRegister(Registers.PowerMode));
            }
            set
            {
                _bno055.WriteRegister(Registers.PowerMode, value);
                Thread.Sleep(15);
            }
	    }

        /// <summary>
        ///     Get / set the current operating mode for the sensor.
        /// </summary>
        /// <remarks>
        ///     Mode change takes 7-19 ms.
        /// </remarks>
	    public byte OperatingMode
	    {
	        get
	        {
                return(_bno055.ReadRegister(Registers.OperatingMode));
	        }
	        set
	        {
	            if (value > OperatingModes.MaximumValue)
	            {
	                throw new ArgumentOutOfRangeException();
	            }
                _bno055.WriteRegister(Registers.OperatingMode, value);
                Thread.Sleep(20);
	        }
	    }

        /// <summary>
        ///     Get / set the register page.  Page 1 contains a number of configuration registers.
        ///     Page 0 contains the sensor information.
        /// </summary>
        /// <remarks>
        ///     Most of the operating in this class are on the sensor data.  It is therefore
        ///     crucial that the sensor is left accessing Page 0.  Methods / properties that
        ///     require access to the registers in Page 1 should change to Page 1, complete
        ///     the work and then return the system back to Page 0.
        /// </remarks>
	    private byte Page
	    {
            get
            {
                return _bno055.ReadRegister(Registers.PageID);
            }
	        set
	        {
	            if ((value != 0) && (value != 1))
	            {
	                throw new ArgumentOutOfRangeException();
	            }
	            _bno055.WriteRegister(Registers.PageID, value);
	        }
	    }

        /// <summary>
        ///     Check if sensor is currently working in Fusion mode.
        /// </summary>
	    public bool IsInFusionMode
	    {
	        get
	        {
	            return ((OperatingMode == OperatingModes.Compass) || 
                        (OperatingMode == OperatingModes.MagnetForGyroscope) ||
	                    (OperatingMode == OperatingModes.NineDegreesOfFreedom) ||
	                    (OperatingMode == OperatingModes.InertialMeasurementUnit) ||
	                    (OperatingMode == OperatingModes.NineDegreesOfFreedom));
	        }
	    }

	    /// <summary>
	    ///     Get the accelerometer readings from the last call to Read().
	    /// </summary>
	    public Vector AccelerometerReading
	    {
	        get
	        {
	            if (_sensorReadings == null)
	            {
	                throw new InvalidOperationException("Read() must be called before the sensor readings are available.");
	            }
	            if ((OperatingMode != OperatingModes.Accelerometer) &&
	                (OperatingMode != OperatingModes.AccelerometerMagnetometer) &&
	                (OperatingMode != OperatingModes.AccelerometerMagnetometerGyroscope) &&
	                (OperatingMode != OperatingModes.AccelerometeraGyroscope))
	            {
	                throw new Exception("Accelerometer is not currently enabled.");
	            }
	            double divisor = 1.0;
	            if (_accelerometerUnits == Units.MetersPerSecond)
	            {
	                divisor = 100.0;
	            }
	            return ConvertReadingsToVector(Registers.AccelerometerXLSB - Registers.StartOfSensorData, divisor);
	        }
	    }

        /// <summary>
        ///     Get the magnetometer readings.
        /// </summary>
	    public Vector MagnetometerReading
	    {
	        get
	        {
	            if (_sensorReadings == null)
	            {
	                throw new InvalidOperationException("Read() must be called before the sensor readings are available.");
	            }
	            if ((OperatingMode != OperatingModes.Magnetometer) &&
	                (OperatingMode != OperatingModes.AccelerometerMagnetometer) &&
	                (OperatingMode != OperatingModes.AccelerometerMagnetometerGyroscope) &&
	                (OperatingMode != OperatingModes.MagnetometerGyroscope))
	            {
	                throw new Exception("Magnetometer is not currently enabled.");
	            }
	            return ConvertReadingsToVector(Registers.MagnetometerXLSB - Registers.StartOfSensorData, 16.0);
	        }
	    }

        /// <summary>
        ///     Get the gyroscope readings.
        /// </summary>
	    public Vector GyroscopeReading
	    {
	        get
	        {
	            if (_sensorReadings == null)
	            {
	                throw new InvalidOperationException("Read() must be called before the sensor readings are available.");
	            }
	            if ((OperatingMode != OperatingModes.Gyroscope) &&
	                (OperatingMode != OperatingModes.AccelerometeraGyroscope) &&
	                (OperatingMode != OperatingModes.AccelerometerMagnetometerGyroscope) &&
	                (OperatingMode != OperatingModes.MagnetometerGyroscope))
	            {
	                throw new Exception("Gyroscope is not currently enabled.");
	            }
	            double divisor = 16.0;
	            if (_gyroscopeUnits == Units.Radians)
	            {
	                divisor = 900.0;
	            }
	            return ConvertReadingsToVector(Registers.GyroscopeXLSB - Registers.StartOfSensorData, divisor);
	        }
	    }

        /// <summary>
        ///     Orientation in Euler angles.
        /// </summary>
	    public EulerAngles EulerOrientation
	    {
	        get
	        {
	            if (_sensorReadings == null)
	            {
	                throw new InvalidOperationException("Read() must be called before the sensor readings are available.");
	            }
	            if (!IsInFusionMode)
	            {
	                throw new InvalidOperationException("Euler angles are only available in fusion mode.");
	            }
	            double divisor = 16.0;
	            if (_orientationUnits == Units.Radians)
	            {
	                divisor = 900.0;
	            }
	            return ConvertReadingToEulerAngles(Registers.EulerAngleXLSB - Registers.StartOfSensorData, divisor);
	        }
	    }

        /// <summary>
        ///     Get the Quaterion orientation.
        /// </summary>
	    public Quaternion QuaternionOrientation
	    {
            get
            {
                if (_sensorReadings == null)
                {
                    throw new InvalidOperationException("Read() must be called before the sensor readings are available.");
                }
                if (!IsInFusionMode)
                {
                    throw new InvalidOperationException("Quaterionorientation is only available in fusion mode.");
                }
                int start = Registers.QuaternionDataWLSB - Registers.StartOfSensorData;
                short w = (short) ((_sensorReadings[start + 1] << 8) | _sensorReadings[start]);
                short x = (short) ((_sensorReadings[start + 3] << 8) | _sensorReadings[start + 2]);
                short y = (short) ((_sensorReadings[start + 5] << 8) | _sensorReadings[start + 4]);
                short z = (short) ((_sensorReadings[start + 5] << 8) | _sensorReadings[start + 4]);
                double factor = 1.0 / (1 << 14);
                return new Quaternion(w * factor, x * factor, y * factor, z * factor);
            }
	    }

        /// <summary>
        ///     Retrieve the linear acceleration vector (fusion mode only).
        /// </summary>
	    public Vector LinearAcceleration
	    {
	        get
	        {
	            if (_sensorReadings == null)
	            {
	                throw new InvalidOperationException("Read() must be called before the sensor readings are available.");
	            }
	            if (!IsInFusionMode)
	            {
	                throw new InvalidOperationException("Linear accelration vectors are only available in fusion mode.");
	            }
	            double divisor = 1.0;
	            if (_accelerometerUnits == Units.MetersPerSecond)
	            {
	                divisor = 100.0;
	            }
	            return ConvertReadingsToVector(Registers.LinearAccelerationXLSB - Registers.StartOfSensorData, divisor);
	        }
	    }

        /// <summary>
        ///     Retrieve the gravity vector (fusion mode only).
        /// </summary>
	    public Vector GravityVector
	    {
	        get
	        {
	            if (_sensorReadings == null)
	            {
	                throw new InvalidOperationException("Read() must be called before the sensor readings are available.");
	            }
	            if (!IsInFusionMode)
	            {
	                throw new InvalidOperationException("Linear acceleration vectors are only available in fusion mode.");
	            }
	            double divisor = 1.0;
	            if (_accelerometerUnits == Units.MetersPerSecond)
	            {
	                divisor = 100.0;
	            }
	            return ConvertReadingsToVector(Registers.GravityVectorXLSB - Registers.StartOfSensorData, divisor);
	        }
	    }

	    /// <summary>
	    ///     Get the system calibration status.
	    /// </summary>
	    public bool IsSystemCalibrated
	    {
	        get
	        {
	            return (((_bno055.ReadRegister(Registers.CalibrationStatus) >> 6) & 0x03) != 0);
	        }
	    }

	    /// <summary>
	    ///     Get the accelerometer calibration status.
	    /// </summary>
	    public bool IsAccelerometerCalibrated
	    {
	        get
	        {
	            return (((_bno055.ReadRegister(Registers.CalibrationStatus) >> 2) & 0x03) != 0);
	        }
	    }

	    /// <summary>
	    ///     Get the gyroscope calibration status.
	    /// </summary>
	    public bool IsGyroscopeCalibrated
	    {
	        get
	        {
	            return (((_bno055.ReadRegister(Registers.CalibrationStatus) >> 4) & 0x03) != 0);
	        }
	    }

	    /// <summary>
	    ///     Get the magnetometer status.
	    /// </summary>
	    public bool IsMagnetometerCalibrated
	    {
	        get { return ((_bno055.ReadRegister(Registers.CalibrationStatus) & 0x03) != 0); }
	    }

	    /// <summary>
	    ///     Is the system fully calibrated?
	    /// </summary>
	    /// <remarks>
	    ///     The sensor is fully calibrated if the system, accelerometer, gyroscope and megnetometer
	    ///     are all calibrated.
	    /// </remarks>
	    public bool IsFullyCalibrated
	    {
	        get
	        {
	            return (IsAccelerometerCalibrated && IsGyroscopeCalibrated && IsSystemCalibrated &&
	                    IsMagnetometerCalibrated);
	        }
	    }

        #endregion Properties

        #region Constructors

        /// <summary>
		///     Default constructor is private to prevent the developer from calling it.
		/// </summary>
		private BNO055()
		{
		}

		/// <summary>
		///     Create a new BNO055 object using the default parameters for the component.
		/// </summary>
		/// <param name="address">Address of the BNO055 (default = 0x28).</param>
		/// <param name="i2cBus">I2C bus (default = 400 KHz).</param>
		public BNO055(II2cBus i2cBus, byte address = 0x28)
		{
            if ((address != 0x28) && (address != 0x29))
            {
                throw new ArgumentOutOfRangeException("address", "Address should be 0x28 or 0x29.");
            }

            _bno055 = new I2cPeripheral(i2cBus, address);

            if (_bno055.ReadRegister(Registers.ChipID) != 0xa0)
            {
                throw new Exception("Sensor ID should be 0xa0.");
            }
		    _accelerometerUnits = Units.MetersPerSecond;
		    _gyroscopeUnits = Units.Degrees;
		    _orientationUnits = Units.Degrees;
		}

		#endregion Constructors

		#region Methods

		/// <summary>
		///     Force the sensor to make a reading and update the relevant properties.
		/// </summary>
		/// <remarks>
		/// 	This method reads ony the sensor motion / orientation registers.  When
		/// 	accessing the data from a register it is necessary to subtract the
		/// 	accress of the start of the sensor registers from the register required
		/// 	in order to get the correct offset into the _sensorReadings array.
		/// </remarks>
		public void Read()
		{
		    _sensorReadings = _bno055.ReadRegisters(Registers.AccelerometerXLSB,
		                                            (ushort) (Registers.GravityVectorZMSB - Registers.AccelerometerXLSB));
		}

        /// <summary>
        ///     Convert a section of the sensor data into a vector.
        /// </summary>
        /// <param name="start">Start of the data in the _sensorReadings member variable.</param>
        /// <param name="divisor">Divisor to use to convert the data into the correct scale.</param>
        /// <returns>New Vector object containing the specified data.</returns>
	    private Vector ConvertReadingsToVector(int start, double divisor)
	    {
	        var x = (short) ((_sensorReadings[start + 1] << 8) | _sensorReadings[start]);
	        var y = (short) ((_sensorReadings[start + 3] << 8) | _sensorReadings[start + 2]);
	        var z = (short) ((_sensorReadings[start + 5] << 8) | _sensorReadings[start + 4]);
	        return new Vector(x / divisor, y / divisor, z / divisor);
	    }

        /// <summary>
        ///     Convert the sensor readings into an orientation in Euler angles.
        /// </summary>
        /// <param name="start">First of the sensor readings to convert.</param>
        /// <param name="divisor">Divisor to apply to the sensor data.</param>
        /// <returns>EulerAngles object containing the orientation informaiton.</returns>
	    private EulerAngles ConvertReadingToEulerAngles(int start, double divisor)
	    {
	        var x = (short) ((_sensorReadings[start + 1] << 8) | _sensorReadings[start]);
	        var y = (short) ((_sensorReadings[start + 3] << 8) | _sensorReadings[start + 2]);
	        var z = (short) ((_sensorReadings[start + 5] << 8) | _sensorReadings[start + 4]);
            return new EulerAngles(x / divisor, y / divisor, z / divisor);
	    }

        /// <summary>
        ///     Read all of the registers and display their values on the Debug output.
        /// </summary>
	    public void DisplayRegisters()
        {
            var registers = _bno055.ReadRegisters(Registers.ChipID, 0x6a);
            DebugInformation.DisplayRegisters(0x00, registers);
        }

		#endregion
	}
}
